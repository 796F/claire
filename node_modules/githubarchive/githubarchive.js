var fs = require('fs');
var Q = require('q');
var strftime = require('strftime');
var knex = require('knex')({ dialect: 'mysql' });
var vsprintf = require("sprintf-js").vsprintf;

var GAPI = require('googleapis');
var bq = GAPI.bigquery('v2');

var COLUMNS = ['repository_url', 'repository_created_at', 'repository_description', 'repository_forks', 'repository_size',
'repository_name', 'repository_owner', 'repository_open_issues', 'repository_watchers', 'repository_pushed_at', 
'actor_attributes_login', 'actor_attributes_location', 'created_at', 'payload_commit_msg', 'url', 'type'];

var BASE_QUERY = 'SELECT ' + COLUMNS.join(', ') + ' FROM githubarchive:github.timeline ' + 
                 'WHERE repository_owner="%s" AND repository_name="%s" AND created_at > "%s" AND repository_fork="false" '+
                 'ORDER BY created_at ASC';

var QUERY_REQUEST = 'bigquery#queryRequest';

Archive = function(options) {
  this.authClient = new GAPI.auth.JWT(options.iss, options.key_path, undefined, options.scope);
  this.projectId = options.projectId;
  this.table = options.table;
}

Archive.prototype.run = function(options) {
  //authorize, 

  //find out which repositories need to be updated starting from which date

  //call get updated data for each of those repos.
}

Archive.prototype.authorize = function(callback) {
  var self = this;
  return Q.Promise(function(resolve, reject, notify){
    self.authClient.authorize(function(err, tokens) {
      if (err) {
        reject(err);
      }else{
        console.log('got token', tokens.access_token);
        self.tokens = tokens;
        resolve(self);
      }
    });
  });
}

Archive.prototype.getLatestDataForRepository = function(repository_owner, repository_name, last_scan_time){
  //refresh token, then try the request.  
  var self = this;
  return Q.Promise(function(resolve, reject, notify){
    self.authClient.refreshToken_(undefined, function(err, result){
      var date_string = strftime('%F %T', new Date(last_scan_time));
      var sql_query = vsprintf(BASE_QUERY, [repository_owner, repository_name, date_string]);
      
      self.query(sql_query)
      .then(function(result){
        var jobId = result.jobReference.jobId;
        var pageToken = result.pageToken;
        //first page back, notify
        notify(result.rows);

        //paginate and hand it the notify function
        self.paginate(jobId, pageToken, notify)
        .then(function(last_page){
          //end of data, resolve with last page
          notify(last_page.rows);
        }, function(error){
          reject(error);
        }, function(page){
          //piece of data, notify of data.
          notify(page.rows);
        });

      });

    });
  });
}

Archive.prototype.query = function(query){
  //execute a query on github archive, 
  var self = this;
  return Q.Promise(function(resolve, reject, notify){
    var options = {
      auth: self.authClient,
      projectId: self.projectId,
      resource: { 
        kind: QUERY_REQUEST,
        query: query,
        maxResults: 1000,
        defaultDataset: {
          datasetId: 'scan' + Date.now()
        },
        useQueryCache: true 
      }
    };
    bq.jobs.query(options, function(err, result){
      if(err){
        reject(err)
      }else{
        resolve(result);
      }
    });
  });
}

//calls nextPage in a loop on the dataset with next page token until we get all the data.  
Archive.prototype.paginate = function(jobId, pageToken, notify) {
  var self = this;
  return self.nextPage(jobId, pageToken)
  .then(function(result){
    if(result.pageToken){
      notify(result.rows);
      return self.paginate(jobId, result.pageToken, notify);
    }else{
      return result;
    }
  });
}

//requests a single page of our dataset using a page token.  
Archive.prototype.nextPage = function(jobId, pageToken) {
  var self = this;
  return Q.Promise(function(resolve, reject, notify){
    bq.jobs.getQueryResults({
      auth: self.authClient,
      jobId: jobId,
      pageToken: pageToken,
      maxResults: 1000,
      projectId: 'git-scan'
    }, function(err, result){
      if(err){
        reject(err);
      }else{
        resolve(result);
      }
    });
  });
}

module.exports = Archive;
